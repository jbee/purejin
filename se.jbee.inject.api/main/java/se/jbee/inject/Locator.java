/*
 *  Copyright (c) 2012-2019, Jan Bernitt
 *
 *  Licensed under the Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0
 */
package se.jbee.inject;

import se.jbee.lang.Qualifying;
import se.jbee.lang.Type;
import se.jbee.lang.Typed;

import java.io.Serializable;

import static se.jbee.inject.Dependency.dependency;
import static se.jbee.lang.Type.raw;

/**
 * Describes WHAT (type-wise) can be generated by the backing {@link Resource}
 * and WHERE ("location") this should apply and be used.
 */
public final class Locator<T> implements Typed<T>, Qualifying<Locator<?>>,
		Serializable, Comparable<Locator<?>> {

	public static <T> Locator<T> locator(Class<T> type) {
		return new Locator<>(Instance.anyOf(raw(type)));
	}

	public final Instance<T> instance;
	public final Target target;

	public Locator(Instance<T> instance) {
		this(instance, Target.ANY);
	}

	public Locator(Instance<T> instance, Target target) {
		this.instance = instance;
		this.target = target;
	}

	public boolean isUsableFor(Dependency<?> dep) {
		return isUsableNameWise(dep) // check names first since default goes sorts first but will not match any named
				&& isUsableTypeWise(dep)
				&& isUsableTargetWise(dep);
	}

	public boolean isUsableInstanceWise(Dependency<?> dep) {
		return isUsableNameWise(dep) && isUsableTypeWise(dep);
	}

	/**
	 * Does the {@link Type} of this {@link Locator} one that can generate an
	 * instance that is asked for by the given {@link Dependency}?
	 * <p>
	 * OBS! This is not the classic type assignability. Partly the logic is
	 * reversed. A {@link Locator} that declares {@code ? extends Number}
	 * expresses that be can create any and all kinds of {@link Number}s. So a
	 * check would be reversed and check that the required type, say {@link
	 * Integer} can be assigned to the offered type, here {@link Number}. Then
	 * {@link Integer} is an available type.
	 */
	public boolean isUsableTypeWise(Dependency<?> dep) {
		return isGeneratableType(dep.type(), instance.type());
	}

	private static boolean isGeneratableType(Type<?> required, Type<?> offered) {
		if (offered.isAssignableTo(required))
			return true;
		if (offered.isUpperBound())
			return required.isAssignableTo(offered);
		if (!required.rawType.isAssignableFrom(offered.rawType)
				|| !offered.hasTypeParameter())
			return false;
		Type<?>[] offeredParams = offered.parameters();
		for (int i = 0; i < offeredParams.length; i++) {
			if (!isGeneratableTypeParameter(required.parameter(i), offeredParams[i]))
				return false;
		}
		return true;
	}

	private static boolean isGeneratableTypeParameter(Type<?> required,
			Type<?> offered) {
		if (offered.isUpperBound())
			return required.isAssignableTo(offered);
		// (not a ? extends parameter)
		if (required.rawType != offered.rawType)
			return false;
		// ok, these are of the same raw type, what about the parameters?
		return isGeneratableType(required, offered);
	}

	/**
	 * Does the given {@link Dependency} occur in the right package and for the
	 * right target ?
	 */
	public boolean isUsableTargetWise(Dependency<?> dep) {
		return target.isUsableFor(dep);
	}

	/**
	 * Does this {@link Locator} provide the instance wanted by the given
	 * {@link Dependency}'s {@link Name}
	 */
	public boolean isUsableNameWise(Dependency<?> dep) {
		return instance.name.isCompatibleWith(dep.instance.name);
	}

	public Locator<T> indirect(boolean indirect) {
		return target.indirect == indirect
			? this
			: new Locator<>(instance, target.indirect(indirect));
	}

	@Override
	public Type<T> type() {
		return instance.type();
	}

	@Override
	public boolean moreQualifiedThan(Locator<?> other) {
		return Qualifying.compareRelated(instance, other.instance, target,
				other.target);
	}

	@Override
	public int compareTo(Locator<?> other) {
		int res = instance.compareTo(other.instance);
		if (res != 0)
			return res;
		return target.compareTo(other.target);
	}

	@Override
	public String toString() {
		return instance + "" + target;
	}

	@Override
	public <E> Locator<E> typed(Type<E> type) {
		return new Locator<>(instance.typed(type), target);
	}

	public boolean equalTo(Locator<?> other) {
		return this == other
			|| instance.equalTo(other.instance) && target.equalTo(other.target);
	}

	@Override
	public boolean equals(Object obj) {
		return obj instanceof Locator && equalTo((Locator<?>) obj);
	}

	@Override
	public int hashCode() {
		return instance.hashCode() ^ target.hashCode();
	}

	/**
	 * @since 8.1
	 * @return a {@link Dependency} that {@link #isUsableFor(Dependency)} this
	 *         {@link Locator}.
	 */
	public Dependency<T> toDependency() {
		Dependency<T> dep = dependency(instance);
		if (target != Target.ANY) {
			if (!target.parents.isAny()) {
				for (Instance<?> p : target.parents)
					dep = dep.injectingInto(p);
			}
			dep = dep.injectingInto(target.instance);
		}
		return dep;
	}

}
